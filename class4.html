
<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="chrome=1" />

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />


<title>Intro Menciones I: Clase 4</title>

<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>-->
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>-->

<!-- General and theme style sheets -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.5.0/css/reveal.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.5.0/css/theme/white.css" id="theme">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.5.0/lib/css/zenburn.css">
<!-- Theme used for syntax highlighting of code -->
<!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/lib/css/monokai.css">-->

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.5.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
}

</script>

<!--[if lt IE 9]>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.5.0/lib/js/html5shiv.js"></script>
<![endif]-->

<!-- Loading the mathjax macro -->
<!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: false }
        }
    });
    </script>
    <!-- End of mathjax configuration -->

<!-- Get Font-awesome from cdn -->
<!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css">-->


        <style type="text/css">
            .container{
                        display: flex;
                      }
            .col{
                      flex: 1;
                }
            .reveal section p {
                      display: inline-block;
                      font-size: 0.6em;
                      line-height: 1.2em;
                      vertical-align: top;
                      text-align: left;
            }
            .reveal section li {
                      font-size: 0.6em;
            }
            .reveal section td {
                      font-size: 0.6em;
            }
            .reveal section img {
                      border: none;
            }
            .reveal section figcaption {
                      font-size: 0.6em;
            }
        </style>

	</head>
	<body>
			<div class="reveal">
			<div class="slides">

<section><h3>Algoritmos</h3></section>

<section><h4>¿Qué es un algoritmo?</h4>
<div class="container">
<div class="col">
<p>Como vimos en la clase anterior, un algoritmo es como una receta: un conjunto de instrucciones para completar una tarea.</p>
</div>
<div class="col">
<img src="class4_images/receta1.png" height=300>
</div>
</div>
</section>

<section><h4>¿Qué es un algoritmo?</h4>
<p>Un conjunto prescrito de instrucciones o reglas bien definidas cuyo fin es obtener una solución. La palabra viene del nombre del matemático, Mohammed ibn-Musa al-Khwarizmi, que formaba parte de la corte real en Baghdad, y vivió desde el año 780 hasta 850 (aprox).</p>
<figure>
<img src="class4_images/al_kwarizmi.jpg" height=300>
<figcaption>Al-Kwarizmi</figcaption>
</figure>
</section>

<section><h4>Algoritmos</h4>
<ul>
<li>Los algoritmos son independientes de los medios utilizados para completar la tarea.</li>
<li>El mismo algoritmo podría implementarse con lapiz y papel, un computador, un abaco, etc.</li>
<li>Por lo tanto, son independientes del <i>lenguaje de programación</i> que usamos.</li>
<li>Un programa de computador es simplemente una implementación o realización de un algoritmo.</li>
</ul>
</section>

<section><h4>Aproximación del número $\pi$</h4>
<ul>
<li>$\pi$ es un <i>número irracional</i> y es la relación entre la longitud de una circunferencia y su diámetro.</li>
<li>El matemático Chino Liu Hui (225-295) hizo una aproximación de $\pi$ en el siglo III.</li>
</ul>
<div class="container">
<div class="col">
<img src="class4_images/pi_longitud_diametro.png" height=200>
</div>
<div class="col">
<img src="class4_images/liu_hui_pi.png" height=200>
</div>
</div>
</section>

<section><h4>Aproximación del número $\pi$</h4>
<p>Liu Hui, usando polígonos de 3072 lados, encontró:</p>
<p>$$\pi \approx 3,1416$$</p>
</section>

<section><h4>Aproximación del número $\pi$</h4>
<p>El matemático y astrónomo Chino Zu Chongzhi (429-500) y su hijo Zu Gengzhi (480-525) usaron polígonos de 24576 lados...</p>
<p>$$3,1415926 < \pi < 3,1415927$$</p>
<p>Nadie mejoró este resultado durante los siguientes 1000 años!</p>
</section>

<section><h4>Precisión y rapidez de un algoritmo</h4>
<ul>
<li>La precisión del resultado y la rapidez en obtenerla dependen del algoritmo usado.</li>
<li>Si el algoritmo está diseñado mal, el problema será mucho más difícil de resolver.</li>
</ul>
</section>

<section><h4>Diseño del algoritmo</h4>
<ul>
<li>El primer paso para resolver un problema computacionalmente es diseñar el algoritmo.</li>
<li>Del mismo modo que un edificio no puede construirse sin un plan de arquitecto, deberíamos planificar nuestro método para resolver el problema antes de programar.</li>
</ul>
<figure>
<img src="class4_images/flow_diagram.jpg">
</figure>
</section>

<section><h4>Diseño del algoritmo</h4>
<ul>
<li>Lista de instrucciones</li>
<li>Diagrama de flujo</li>
<li>Pseudo-código</li>
</ul>
<div class="container">
<div class="col">
<img src="class4_images/algoritmo1.png" height=300>
</div>
<div class="col">
<img src="class4_images/pseudocodigo.png" height=300>
</div>
</div>
</section>

<section><h4>Un ejemplo: ordenar números</h4>
<div class="container">
<div class="col">
<ul>
<li> Dado un conjunto de números, queremos ordenarlos en orden ascendiente.
<li> ¿Cómo podemos hacer eso? 
</ul>
</div>
<div class="col">
<img src="class4_images/numbers.jpg">
</div>
</div>
</section>

<section><h4>Un ejemplo: ordenar números</h4>
<div class="container">
<div class="col">
<ul>
<li>No es necesario pensar en ningún lenguaje de programación específica cuando estamos diseñando un algoritmo!</li>
<li>Primero, hay que pensar en los pasos lógicos que cualquier persona puede seguir para convertir una lista de números sin orden en una lista de números ordenados...</li>
</ul>
</div>
<div class="col">
<img src="class4_images/numbers.jpg">
</div>
</div>
</section>

<section><h4>Un ejemplo de un algoritmo para ordenar números</h4>
<p>Una posible solución a este problema es el siguiente algoritmo (que se llama "quicksort"):</p>
<ol>
<li>Elegir un elemento de la lista, que se llama el elemento <i>pivote</i>.</li>
<li>Colocar todos los números menores que el elemento pivote a la izquierda, y todos los números mayores a la derecha.</li>
<li>Para cada una de estas sublistas, realizar los pasos (1) y (2), e igualmente para cada sublista dentro de las sublistas, etc.</li>
<li>Eventualmente las sublistas tendrán solamente $1$ elemento o ninguno, y estas sublistas estarán ordenadas por definición.</li>
</ol>
<p>$\Rightarrow$ Algoritmo <i>recursivo</i>.</p>
</section>

<section><h4>Quicksort</h4>
<img src="class4_images/Quicksort.png">
</section>

<section><h4>Verificando el algoritmo</h4>
<ul>
<li>Ahora deberiamos averiguar que el algoritmo funciona en todos casos.</li>
<li>Típicamente es difícil demsotrar conclusivamente que un algoritmo siempre funcionaría.</li>
<li>Hay un método de demostración que se llama <i>el método de inducción</i> que frecuentemente se puede aplicar a algoritmos, en particular si procesan datos en trozos discretos.</li>
<li>Para nosotros, como científicos usando computadores (y no informáticos) solamente tenemos que averiguar que el algoritmo funciona en las circunstancias relevantes a nuestro problema.</li>
</ul>
</section>

<section><h4>Eligiendo el mejor algoritmo</h4>
<ul>
<li>¿Cómo sabemos que el algoritmo que hemos diseñado es la "mejor" solución?</li>
<li>¿Qué significaría "mejor" en este caso?</li>
<li>Típicamente significa el <b>más preciso </b>y el <b>más rápido</b>.</li>
<li>Precisión es normalmente el primer aspecto de un algoritmo que verificamos.</li>
<li>Calcular la rapidez de un algoritmo es un problema desafiante. ¿Cómo podemos comparar la rapidez de dos algoritmos?</li>
</ul>
</section>

<section><h4>Determinando la rapidez de un algoritmo</h4>
<ul>
<li>Recordar que un algoritmo es independiente de los medios utilizados para implementarlo.</li>
<li>Este significa que el algoritmo es independiente del computador que usamos y el lenguaje de programación.</li>
<li>Por lo tanto, podemos caracterizar la "rapidez" de un algoritmo en una manera que no refiere a la velocidad del
    procesador, el número de procesadores, si usamos Python o C, etc.</li>
</ul>
</section>

<section><h4>Complejidad algorítmica</h4>
<ul>
<li>En la computación la rapidez de un algoritmo se define en términos de su "complejidad".</li>
<li>Determinamos la complejidad de un algoritmo por la consideración del <b>número de pasos</b> que el algoritmo tiene que ejecutar para completar su tarea.</li>
</ul>
</section>

<section><h4>Complejidad algorítmica</h4>
<ul>
<li>Pero, ¿qué es un "paso" para un algoritmo?</li>
<li>La definición exacta de lo que constituye un "paso" depende del algoritmo.</li>
<li>NO es algo al nivel del procesador y sus ciclos de operación.</li>
<li>En el análisis de algoritmos, estamos pensando al nivel de los cálculos necesarios en el algoritmo.</li>
</ul>
</section>

<section><h4>Quicksort</h4>
<img src="class4_images/Quicksort.png">
</section>

<section><h4>Complejidad algorítmica</h4>
<ul>
<li>De hecho, estamos más interesados, cuando hablamos de complejidad, en como el algoritmo se <i>escala</i> cuando lo aplicamos a más datos.</li>
<li>En el caso de "quicksort" queremos saber que tan rápido o lento es el algoritmo cuando lo aplicamos a una lista de $100$ elementos, comparado a $10$, o $1000000$ elementos comparado a $1000$, etc.</li>
</ul>
</section>

<section><h4>Complejidad algorítmica: N-cuerpos</h4>
<ul>
<li>¿Cómo describimos la complejidad de un algoritmo?</li>
<li>Vamos a usar un algoritmo más simple que "quicksort".</li>
<li>Analizaremos un tipo de simulación computacional que se usa mucho en la astrofísica: <span style="color:blue">simulaciones de N-cuerpos</span>.</li>
</ul>
<div class="container">
<div class="col">
<img src="class4_images/Quicksort.png" height=250>
</div>
<div class="col">
<img src="class4_images/model_plot.png" height=250>
</div>
</div>
</section>

<section><h4>Complejidad algorítmica: N-cuerpos</h4>
<ul>
                    <li>El problema de N-cuerpos consiste en un sistema de N
                        partículas sujetas a la acción de su propia gravedad
                        (como el Sistema Solar).</li>
<li>Fuerzas $\Rightarrow$ aceleraciones $\Rightarrow$ velocidades.</li>
<li>Se puede actualizar las posiciones de las partículas con sus velocidades: el sistema se evoluciona en el tiempo.</li>
</ul>
<img src="class4_images/nbody.jpg">
</section>

<section><h4>Complejidad algorítmica: N-cuerpos</h4>
<div class="container">
<div class="col">
<ul>
<li>El "paso" básico en este algoritmo es el calculo de las fuerzas entre cada par de partículas.</h4>
<li>Con solo 2 partículas tenemos que calcular solamente la fuerza entre un par y listo! (1 paso).</h4>
</ul>
</div>
<div class="col">
<img src="class4_images/2body.png">
</div>
</div>
</section>

<section><h4>Complejidad algorítmica: N-cuerpos</h4>
<div class="container">
<div class="col">
<ul>
<li>3 partículas: 3 pares posibles $(1,2)$, $(1,3)$, $(2,3)$. (3 "pasos" en el algorítmo)</li>
<li>¿$n$ partículas?</li>
<li>La pregunta es, ¿cuántos pares únicos podemos formar de $n$ partículas?</li>
</ul>
</div>
<div class="col">
<img src="class4_images/3body.png">
</div>
</div>
</section>

<section><h4>Complejidad algorítmica: N-cuerpos</h4>
<div class="container">
<div class="col">
<ul>
<li>Hay $n$ pares para cada partícula (incluyendo un "par" de la partícula con si misma).</li>
<li>Hay $n$ partículas $\Rightarrow$ número total de pares es $n \times n = n^2$.</li>
<li>Para eliminar los pares falsos (de una partícula con si misma), de los cuales hay $n$, podemos restar $n$ de $n^2$.</li>
</ul>
</div>
<div class="col">
<img src="class4_images/nbody_rot.jpg" height=500>
</div>
</div>
</section>

<section><h4>Complejidad algorítmica: N-cuerpos</h4>
<div class="container">
<div class="col">
<ul>
<li>Pero, estamos contando los mismos pares dos veces: el par $(3,5)$ es el mismo par como $(5,3)$.</li>
<li>Multiplicamos por $1/2$, para obtener el número final de pares <span style="color:blue">únicos</span>: $\frac{1}{2}(n^2 - n)$.</li>
</ul>
</div>
<div class="col">
<img src="class4_images/nbody_rot.jpg" height=500>
</div>
</div>
</section>

<section><h4>Complejidad algorítmica: notación O grande</h4>
<ul>
<li>La complejidad del algoritmo está dada simplemente por contar el número de pares únicos!</li>
<li>Expresamos la complejidad en notación "Big-O" (O grande): $\mathcal{O}$.</li>
</ul>
</section>

<section><h4>Complejidad algorítmica: notación O grande</h4>
<div class="container">
<div class="col">
<ul>
<li>Número de pares de $n$ partículas es $\frac{1}{2}(n^2 - n)$. Usamos el término del grado más alto del polinomial (sin preocuparnos por los coeficientes): $\mathcal{O}(n^2)$.</li>
<li>Este es porque este término crece más rápido con $n$ mayor que los otros, y el factor de $1/2$ no es muy importante.</li>
</ul>
</div>
<div class="col">
<img src="class4_images/n2_complexity.png">
</div>
</div>
</section>

<section><h4>Complejidad algorítmica: notación O grande</h4>
<ul>
<li>El algoritmo de N-cuerpos tiene una complejidad de $O(n^2)$.</li>
<li>Si la implementación del algorítmo (i.e. el programa) demora $2$ segundos para $10$ partículas (i.e. $n=10$),</li>
<ul>
<li> $t = cn^2$, $2 = c(10^2) \Rightarrow c = 0,02$.</li>
</ul>
<li> El programa demorará aproximadamente $200$ segundos para $n = 100$ partículas.</li>
<ul>
<li>$t = cn^2$, $t = (0,02) \times (100^2) = 200$.</li>
</ul>
<li>Este algoritmo, por lo tanto, se <i>escala</i> muy mal: demora mucho más tiempo cuando aumentamos el número de partículas un poco.</li>
</ul>
</section>

<section><h4>Diferentes complejidades</h4>
<img src="class4_images/algorithmic_complexity.png">
</section>

<section><h4>¿Por qué es importante saber la complejidad de un algoritmo?</h4>
<ul>
<li>Ejemplo: si uno tiene un <i>software</i> para simulaciones de N-cuerpos, pero sin información de su complejidad algoritmica.</li>
<li>Quizás uno lo usa para simular un cúmulo de estrellas muy pequeña con $20$ partículas, y tarda $1$ hora para completarse.</li>
<li> Si el algoritmo tiene complejidad $\mathcal{O}(n^2)$ y uno intenta simular una galaxia con 200.000 partículas, se demorará...</li>
<ul>
<p class="fragment"><span style="color:red">11.000 años!</span></p>
<div>
<p class="fragment">En qué momento se deja de esperar..?</p>
</div>
</ul>
</section>

<section>
<section><h4>Un problema no resuelto de la informática</h4>
<p>Un punto entre paréntesis: existe un problema muy interesante y sin resolución todavía en la informática que está
    relacionado con complejidad algorítmica.</p>
<blockquote class="fragment">
<p>¿$P = NP$?</p>
<p>¿Dado un problema, el cual es posible de <b>verificar</b> su solución
    <i>rápidamente</i>: es posible también <b>resolverlo</b> <i>rápidamente</i> (en
    tiempo "polinomial")?
</p>
<!--
    <p>¿Es posible resolver <i>rápidamente</i> cualquier problema cuya solución se puede comprobar <i>rápidamente</i> (en
    tiempo "polinomial")?</p>
                            -->
</blockquote>
</section>

<section><h4>Un problema no resuelto de la informática</h4>
<ul>
<li>Acuerdense que hay muchos algoritmos posibles para resolver un cierto problema. Quizás algunos tendrán complejidad
    baja (son "rápidos") y otros tendrán complejidad alta (son "lentos").</li>
<li>La naturaleza del problema dictará si algoritmos "rápidos" existen.</li>
</ul>
</section>

<section><h4>Un problema no resuelto de la informática</h4>
<div class="container">
<div class="col">
<ul>
<li class="fragment">Ejemplo: el juego <i>Sudoku</i>.</li>
<li class="fragment">Es muy fácil comprobar que tenemos una solución de un <i>Sudoku</i>. Pero, no es fácil resolver el <i>Sudoku</i>, y la complejidad del problema (y los algoritmos para encontrar una solución) crece <b>exponencialmente</b> con el tamaño de la cuadrícula.</li>
<li class="fragment">Así que, el problema es muy difícil de resolver (generalmente) pero muy fácil de verificar.</li>
</ul>
</div>
<div class="col">
<img src="class4_images/sudoku.png" height=300>
</div>
</div>
</section>

<section><h4>¿$P = NP$?</h4>
<ul>
<li>Problemas "rápidos" de verificar: problemas NP (tiempo <i>polinomial no determinista</i>).</li>
<li>Problemas "rápidos" de resolver: problemas P (tiempo <i>polinomial</i>).</li>
<li>Problemas donde una solución general a uno de los problemas daría la solución a todos los otros: problemas NP-completos.</li>
</ul>
</section>

<section><h4>¿$P = NP$?</h4>
<div class="container">
<div class="col">
<ul>
<li>En palabras el misterio es: ¿el conjunto de problemas cuyos soluciones son fáciles de verificar es <i>igual</i> al conjunto de problemas que son fáciles de resolver, o no?</li>
</ul>
</div>
<div class="col">
<img src="class4_images/p_np.png">
</div>
</div>
</section>

<section><h4>¿$P = NP$?</h4>
<div class="container">
<div class="col">
<ul>
<li>Si $P = NP$: con una solución rápida a UNO de los problemas NP-completo, tenemos una solución rápida para TODOS los otros problemas NP-completo.</li>
<li>Muchos problemas del mundo real en la ciencia y la informática (y muchos otros áreas) son problemas NP-completo.</li>
</ul>
</div>
<div class="col">
<img src="class4_images/p_np.png">
</div>
</div>
</section>

<section><h4>¿$P = NP$?</h4>
<ul>
<li>Todavía nadie ha encontrado una solución rápida a un problema-NP, lo que sugiere que $P \neq NP$, pero aún no hay una demostración matemática.</li>
<li>El problema de ¿$P = NP$? es uno de los problemas del <i>Millenium Prize</i> en la matemática.</li>
<li>Si alguien lo resuelve, gana <span style="color:blue">\$1.000.000!</span></li>
</ul>
</section>
</section>

<section><h3>Precisión</h3></section>

<section><h4>Precisión en la computación</h4>
<p>Estamos todos acostumbrados a calcular cosas en una calculadora (o en el teléfono) y confiar en el resultado. Pero, de hecho, los computadores nunca son perfectamente precisos.</p>
<p>$\Rightarrow$ Tienen una memoria finita</p>
<p>$\Rightarrow$ Utilizan números binarios.</p>
</section>

<section><h4>Memoria finita</h4>
<ul>
<li>Los computadores no pueden almacenar numeros a una precisión arbitrariamente alta.</li>
<li>Por ejemplo: el número $\pi$ es un número irracional (de hecho, trascendente).</li>
</ul>
<img src="class4_images/pi.jpeg">
</section>


<section><h4>Memoria finita</h4>
<ul>
<li>No se puede escribir $\pi$ en ningún sistema de números (base-10, base-20, lo que sea) a una precisión arbitraria porque requeriría un número infinito de dígitos.</li>
<li>Por lo tanto, cualquier cálculo en un computador que involucra $\pi$ tiene que ser (hasta cierto punto) inexacto porque el número está truncado.</li>
</ul>
</section>

<section><h4>Límites en tamaños de variables</h4>
<ul>
<li>De hecho, la mayoría de los lenguajes de programación ponen límites en los tamaños de los números que se puede guardar en una variable.</li>
<li>En Python un <i>float</i> normal no puede ser mayor que $10^{308}$. ¿Por qué? Tiene que ver con como los computadores guardan números en binario.</li>
</ul>
</section>

<section><h4>Estándar para números de punto flotante</h4>
<ul>
<li>Existe un estandar en la informática, llamado IEEE754, que define como guardar un número de punto flotante en la
    memoria de un computador.</li>
<li>En Python hay un total de $64$ bits para guardar un <i>float</i>. De estos, $1$ bit es para el signo (+/-), $11$
    bits son para el exponente, y $52$ bits son para el significando (fracción, mantisa, coeficiente).</li>
</ul>
<img src="class4_images/double_float.png">
</section>

<section><h4>Estándar para números de punto flotante</h4>
<ul>
<li>Con $11$ bits en el exponente, el rango de números decimales que se puede guardar es de $-1024$ a $1023$.</li>
<li>$2^{1023}$ es aproximadamente $10^{308}$.</li>
</ul>
<img src="class4_images/double_float.png">
</section>

<section><h4>Precisión de números de punto flotante</h4>
<ul>
<li>Entonces, todos los números de punto flotante en un computador están truncados.</li>
<li>En la mayoría de los lenguajes hay <i>floats</i> de precisión-simple (<i>single-precision</i>) y precisión-doble (<i>double-precision</i>).</li>
<li>Precisión-simple: $32$ bits. Precisión-doble: $64$ bits.</li>
</ul>
<img src="class4_images/single_float.png">
<ul>
<li>Es importante saber cual se ocupa, ya que determina la precisión numérica del algoritmo.</li>
                    <li>Ojo: no siempre es más conveniente utilizar
                        Precisión-doble, ya que requiere el doble de memoria que
                    Precisión-simple.</li>
</ul>
</section>

<section><h4>Precisión de la máquina</h4>
<ul>
<li>El grado de precisión que uno puede obtener en una variable se llama la <span style="color:blue">precisión de la máquina</span> (<i>machine precision</i>), $\epsilon$.</li>
<li>No importa el programa que escribamos, ni el algoritmo que usamos, <b>nunca</b> calcularemos valores a una precisión mayor que la precisión de la máquina.</li>
                    <li>Las arquitecturas de computadores modernos son de
                        64-bits.</li>
<li>Notese que algunos lenguajes permiten control en la cantidad de memoria asignada a variables de distintos tipos, y por eso podemos obtener valores muy pequeños para $\epsilon$ (es decir, precisión extremadamente alta).</li>
</ul>
<p>Precisión doble: $\epsilon = 2^{-53} \approx 1,11 \times 10^{-16}$.</p>
</section>

<section><h4>El problema de precisión finita</h4>
<ul>
<li>Ejemplo: si multiplicamos un número muy pequeño por un número muy grande, usando precisión-simple: el <i>significando</i> del número tendrá $23$ bits.</li>
<li>Estos $23$ bits corresponden a $7-8$ dígitos decimales (depende del número).</li>
<li>El septimo u octavo dígito en la representación decimal del número será incorrecto (por el truncamiento del número).</li>
</ul>
</section>

<section><h4>El problema de precisión finita</h4>
<ul>
                    <li>Dicha situación podría aparecer al realizar el siguiente cálculo:</li>
<li>La constante gravitacional en unidades SI: $6,67408 \times 10^{-11}$ m$^3$ kg$^{-1}$ $s^{-2}$.</li>
<li>La masa solar en unidades SI: $2 \times 10^{30}$ kg.</li>
<li>Al multiplicar ambas cantidades, el septimo dígito (último
                        digito válido en precisión simple) del resultado será un número de magnitud $10^{13}$!</li>
<li>Este número podría ser suficientemente grande para modificar otros números en el cálculo e introducir errores.</li>
</ul>
</section>

<section><h4>Números que no se puede representar exactamente en binario</h4>
<ul>
<li>Otro problema: existen números que no podemos representar exactamente en el sistema binario.</li>
<li>En el sistema decimal, no se puede representar $1/3$ exactamente (es igual a $0.3333333\ldots$).</li>
</ul>
</section>

<section><h4>Números que no se puede representar exactamente en binario</h4>
<ul>
<li>Por las mismas razones, hay fracciones que no se puede representar exactamente en <span style="color:red">binario</span>.</li>
<li>Un ejemplo común es el número $0.1$ (una representación <i>exacta</i> de $1/10$ en el sistema decimal).</li>
<li>En binario, este tiene la representación $0.000110011001100110011\ldots$.
                        Por lo tanto, <b>nunca</b> tendremos el valor $0.1$
                        representado <b>exactamente</b> en el computador - siempre habrá un error del tamaño de la precisión de la máquina.</li>
</ul>
</section>

<section><h4>Resumen</h4>
<ul>
<li> Algoritmos son procesos estructurados diseñados para resolver un problema especifico.</li>
<li> El primer paso, en cualquier tarea computacional, es pensar sobre el algoritmo, diseñarlo y planificarlo.</li>
<li>La implementación de un algorítmo es un <span style="color:blue">programa</span>.</li>
<li>Un algoritmo bueno es <i>rápido</i> y <i>preciso</i>.</li>
<li>La complejidad algorítmica: como escala su tiempo de ejecución con la cantidad de datos que usamos como entrada al
    algoritmo.</li>
</ul>
<p>$\Rightarrow$ Notación O-grande (Big-O), $\mathcal{O}$.</p>
</section>

<section><h4>Resumen</h4>
<ul>
<li>La exactitud de los algoritmos está afectada por la precisión de las variables.</li>
<li>Casi todos los números que se representan en el computador tienen un cierto nivel de imprecisión.</li>
<li>Siempre debemos estar consciente de esto cuando escribimos programas.</li>
</ul>
</section>


			</div>
		</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.5.0/lib/js/head.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.5.0/js/reveal.js"></script>

<script>

			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                transition: 'slide',

                math: {
		                mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js',
                        //mathjax: '/home/graeme/Documents/talks/reveal.js/MathJax-2.7.3/MathJax.js',
		                config: 'TeX-AMS_HTML-full', // See http://docs.mathjax.org/en/latest/config-files.html
		                // pass other options into `MathJax.Hub.Config()`
		                TeX: { Macros: { RR: "{\\bf R}" } }
	                  },

				dependencies: [
					{ src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.5.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad();}}
				]
			});
</script>

</script>
	</body>
</html>
